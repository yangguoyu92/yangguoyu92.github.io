<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yang&#39;s Blog</title>
  <meta name="author" content="Yang Guoyu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Yang&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="Yang&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Yang&#39;s Blog</a></h1>
  <h2 class="subtitle"></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-07-15T12:39:29.000Z"><a href="/2015/07/15/Minimum-Depth-of-Binary-Tree/">2015-07-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/15/Minimum-Depth-of-Binary-Tree/">Minimum-Depth-of-Binary-Tree</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Problem:">Problem:</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="external">from LeetCode</a></p>
<h3 id="Solution:">Solution:</h3><p>首先想到用递归方法求解，思路如下：</p>
<ol>
<li>判断根节点是否为空</li>
<li>若根节点为空，则深度为0，返回。若根节点不为空，则判断左孩子和右孩子是否为空。</li>
<li>若左右孩子都为空，说明此节点是叶子节点，深度为1，返回。若左右孩子不都为空，则递归求解不为空的孩子的深度，加1返回。</li>
</ol>
<p>代码：</p>
<pre><code>public class Solution {
    public int minDepth(TreeNode root) {
        int <span class="variable">depth =</span> <span class="number">0</span>;
        <span class="keyword">if</span>(<span class="variable">root =</span>= <span class="constant">null</span>) {
            <span class="variable">depth =</span> <span class="number">0</span>;
        }<span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="variable">left =</span>= <span class="constant">null</span> &amp;&amp; root.<span class="variable">right =</span>= <span class="constant">null</span>) {
            <span class="variable">depth =</span> <span class="number">1</span>;
        }<span class="keyword">else</span> {
            int <span class="variable">minLeft =</span> minDepth(root.left);
            int <span class="variable">minRight =</span> minDepth(root.right);
            <span class="keyword">if</span>(<span class="variable">minLeft =</span>= <span class="number">0</span> || <span class="variable">minRight =</span>= <span class="number">0</span>) {
                <span class="variable">depth =</span> minLeft + minRight + <span class="number">1</span>;
            }<span class="keyword">else</span> {
                <span class="keyword">if</span>(minLeft &lt; minRight) {
                    <span class="variable">depth =</span> minLeft + <span class="number">1</span>;
                }<span class="keyword">else</span> {
                    <span class="variable">depth =</span> minRight + <span class="number">1</span>;
                }
            }
        }
        return depth;
    }
}
</code></pre><p>运行时间380ms。</p>
<p>也可以采用广度优先策略遍历二叉树来计算，采用层序遍历的方法和队列的数据结构，思路为：</p>
<ol>
<li>判断根节点是否为空。</li>
<li>若根节点为空，则深度为0，返回；若根节点不为空，将其加入队列，深度加1。</li>
<li>取出队列第一个元素，判断其左右孩子是否为空。若左右孩子都为空，则此节点为叶子节点，返回。若左孩子不为空，将左孩子加入队列，若右孩子不为空，将右孩子加入队列。深度加1。</li>
<li>若队列不为空，则重复3。</li>
</ol>
<p>代码：</p>
<pre><code><span class="keyword">class</span> Solution {
    <span class="keyword">public</span> <span class="built_in">int</span> minDepth(TreeNode root) {
        <span class="built_in">int</span> depth = <span class="number">0</span>;
        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
        <span class="built_in">int</span> parentCount = <span class="number">0</span>;
        <span class="built_in">int</span> childCount = <span class="number">0</span>;
        <span class="keyword">if</span>(root == <span class="literal">null</span>) {
            return depth;
        }<span class="keyword">else</span> {
            queue.add(root);
            parentCount = <span class="number">1</span>;
            depth++;
            <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>()) {
                TreeNode firstNode = queue.poll();
                parentCount--;
                <span class="keyword">if</span>(firstNode.<span class="built_in">left</span> == <span class="literal">null</span> &amp; firstNode.<span class="built_in">right</span> == <span class="literal">null</span>) {
                    return depth;
                }
                <span class="keyword">if</span>(firstNode.<span class="built_in">left</span> != <span class="literal">null</span>) {
                    queue.add(firstNode.<span class="built_in">left</span>);
                    childCount++;
                }
                <span class="keyword">if</span>(firstNode.<span class="built_in">right</span> != <span class="literal">null</span>) {
                    queue.add(firstNode.<span class="built_in">right</span>);
                    childCount++;
                }
                <span class="keyword">if</span>(parentCount==<span class="number">0</span>) {
                    depth++;
                    parentCount = childCount;
                    childCount = <span class="number">0</span>;
                }
            }
        }
        return depth;
    }
}
</code></pre><p>运行时间400ms。</p>
<p>同样也可以采用深度优先策略遍历二叉树。二叉树的深度优先遍历有三种遍历方法：前序遍历、中序遍历、后序遍历。通常通过栈的数据结构来实现。栈是实现递归最常用的数据结构。第一种所用的递归方法即为中序遍历。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-07-13T11:36:42.000Z"><a href="/2015/07/13/Palindrome-Linked-List/">2015-07-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/13/Palindrome-Linked-List/">Palindrome Linked List</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Problem:">Problem:</h3><p>Given a singly linked list, determine if it is a palindrome.</p>
<p><strong>*Follow up:</strong> Could you do it in O(n) time and O(1) space?*</p>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">from LeetCode</a></p>
<h3 id="Solution:">Solution:</h3><p>初始解法：</p>
<pre><code><span class="keyword">public</span> class Solution {
    <span class="keyword">public</span> <span class="built_in">boolean</span> isPalindrome(ListNode head) {
        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">while</span>(head != <span class="keyword">null</span>) {
            list.<span class="built_in">add</span>(head.val);
            head = head.next;
        }
        <span class="built_in">int</span> <span class="built_in">size</span> = list.<span class="built_in">size</span>();
        <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">size</span>/<span class="number">2</span>; i++) {
            <span class="built_in">int</span> first = list.<span class="built_in">get</span>(i);
            <span class="built_in">int</span> end = list.<span class="built_in">get</span>(<span class="built_in">size</span>-<span class="number">1</span>-i);
            <span class="keyword">if</span>(first != end) {
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
}
</code></pre><p>运行时间为428ms。时间复杂度为O(n)，空间复杂度也为O(n)。注意要处理head为空的情况。</p>
<p>题目要求空间复杂度为O(1)。通过查询资料，发现通过翻转链表的方法可以使时间复杂度为O(1)，具体描述如下：</p>
<ol>
<li>找到链表的中点。</li>
<li>将后半部分链表进行翻转。</li>
<li>检查前半部分链表和后半部分链表是否相同。</li>
</ol>
<p>修改后的代码如下：</p>
<pre><code>public class Solution {
    public boolean isPalindrome(ListNode head) {
                int <span class="variable">size =</span> <span class="number">0</span>;
        ListNode <span class="variable">node =</span> head;
        while (node!=<span class="constant">null</span>) {
            size++;
            <span class="variable">node =</span> node.next;
        }
        int middle;
        <span class="keyword">if</span> (size%<span class="number">2</span> == <span class="number">0</span>) {
            <span class="variable">middle =</span> size/<span class="number">2</span>;
        } <span class="keyword">else</span> {
            <span class="variable">middle =</span> size/<span class="number">2</span> + <span class="number">1</span>;
        }
        int <span class="variable">count =</span> <span class="number">0</span>;
        ListNode <span class="variable">middleNode =</span> head;
        while(count != middle) {
            <span class="variable">middleNode =</span> middleNode.next;
            count++;
        }
        ListNode <span class="variable">currentNode =</span> middleNode;
        ListNode <span class="variable">prevNode =</span> <span class="constant">null</span>;
        ListNode nextNode;
        while (currentNode != <span class="constant">null</span>) {
            <span class="variable">nextNode =</span> currentNode.next;
            currentNode.<span class="variable">next =</span> prevNode;
            <span class="variable">prevNode =</span> currentNode;
            <span class="variable">currentNode =</span> nextNode;
        }
        <span class="variable">middleNode =</span> prevNode;

        for(int <span class="variable">i=</span><span class="number">0</span>; i&lt;size/<span class="number">2</span>; i++) {
            <span class="keyword">if</span> (head.<span class="variable">val =</span>= middleNode.val) {
                <span class="variable">head =</span> head.next;
                <span class="variable">middleNode =</span> middleNode.next;
            } <span class="keyword">else</span> {
                return <span class="constant">false</span>;
            }
        }

        return <span class="constant">true</span>;
    }
}
</code></pre><p>运行时间为444ms。</p>
<p>还有一种递归的方法可以解这个问题，因为其空间复杂度不为O(1)，故以后再讨论。</p>
<h3 id="Tips:">Tips:</h3><ul>
<li>用 “==” 和 “!=” 比较引用类型时，比较的是这两个是否是同一个对象，而不是两个值是否相等。若要比较其值，则要用equals()函数。</li>
</ul>
<h3 id="References:">References:</h3><ul>
<li><a href="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/" target="_blank" rel="external">Function to check if a singly linked list is palindrome</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-07-06T02:33:59.000Z"><a href="/2015/07/06/Min-Stack/">2015-07-06</a></time>
      
      
  
    <h1 class="title"><a href="/2015/07/06/Min-Stack/">Min Stack</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Problem:">Problem:</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.</li>
</ul>
<p><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="external">from LeetCode</a></p>
<h3 id="Solution:">Solution:</h3><p>初始解法：</p>
<pre><code>class MinStack {

    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();

    <span class="keyword">public</span> <span class="keyword">void</span> push(<span class="built_in">int</span> x) {
        nums.<span class="built_in">add</span>(x);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> pop() {
        <span class="built_in">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();
        <span class="keyword">if</span> (<span class="built_in">size</span>&gt;<span class="number">0</span>) {
            nums.remove(<span class="built_in">size</span>-<span class="number">1</span>);
        }
    }

    <span class="keyword">public</span> <span class="built_in">int</span> top() {
        <span class="built_in">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();
        <span class="keyword">if</span>  (<span class="built_in">size</span>&gt;<span class="number">0</span>) {
            <span class="keyword">return</span> nums.<span class="built_in">get</span>(<span class="built_in">size</span>-<span class="number">1</span>);
        } <span class="keyword">else</span> {
            System.out.<span class="built_in">println</span>(<span class="string">"size is 0"</span>);
        }
        <span class="keyword">return</span> (Integer) <span class="keyword">null</span>;
    }

    <span class="keyword">public</span> <span class="built_in">int</span> getMin() {
        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>) {
            <span class="built_in">int</span> <span class="built_in">min</span> = nums.<span class="built_in">get</span>(<span class="number">0</span>);
            <span class="keyword">for</span>(<span class="built_in">int</span> i:nums) {
                <span class="keyword">if</span> (i&lt;<span class="built_in">min</span>) {
                    <span class="built_in">min</span> = i;
                }
            }
            <span class="keyword">return</span> <span class="built_in">min</span>;
        }

        <span class="keyword">return</span> (Integer) <span class="keyword">null</span>;
    }
}
</code></pre><p>运行时间为740ms。显然，检索最小值的时间复杂度为O(n)，并不是常量时间。那么如何使检索的时间复杂度为常量呢？LeetCode的Solution提供了思路：</p>
<blockquote>
<h4 id="Hints:">Hints:</h4><ul>
<li>Consider space-time tradeoff. How would you keep track of the minimums using extra space?</li>
<li>Make sure to consider duplicate elements.</li>
</ul>
<p><strong>O(n) runtime, O(n) space – Extra stack:</strong></p>
<p>Use an extra stack to keep track of the current minimum value. During the push operation we choose the new element or the current minimum, whichever that is smaller to push onto the min stack.</p>
<p><strong>O(n) runtime, O(n) space – Minor space optimization:</strong></p>
<p>If a new element is larger than the current minimum, we do not need to push it on to the min stack. When we perform the pop operation, check if the popped element is the same as the current minimum. If it is, pop it off the min stack too.</p>
</blockquote>
<p>简单来说，就是用空间来换时间。建立另外一个栈来跟踪最小值，暂且称之为最小栈。当执行push操作时，若最小栈为空，则将其存入最小栈，若最小栈不为空，则将push进来的数与最小栈栈顶元素进行比较，若小于或等于栈顶元素，则将其push进最小栈，否则不对最小栈进行操作。当执行pop操作时，将pop操作数与最小栈栈顶元素相比较，若相等，则对最小栈执行pop操作。对于可能有多个相等的最小值的情况，在push时执行的检测是小于等于，也就意味着所有相等的最小值都会被存入最小栈。修改后的代码如下：</p>
<pre><code>class MinStack {

    ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();
    ArrayList&lt;Integer&gt; mins = <span class="keyword">new</span> ArrayList&lt;&gt;();

    <span class="keyword">public</span> <span class="keyword">void</span> push(<span class="built_in">int</span> x) {
        nums.<span class="built_in">add</span>(x);
        <span class="built_in">int</span> minSize = mins.<span class="built_in">size</span>();
        <span class="keyword">if</span>(minSize&gt;<span class="number">0</span>) {
            <span class="built_in">int</span> minTop = mins.<span class="built_in">get</span>(minSize-<span class="number">1</span>);
            <span class="keyword">if</span>(x&lt;minTop || x == minTop) {
                mins.<span class="built_in">add</span>(x);
            }
        }<span class="keyword">else</span>{
            mins.<span class="built_in">add</span>(x);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> pop() {
        <span class="built_in">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();
        <span class="keyword">if</span> (<span class="built_in">size</span>&gt;<span class="number">0</span>) {
            <span class="built_in">int</span> top = nums.<span class="built_in">get</span>(<span class="built_in">size</span>-<span class="number">1</span>);
            <span class="built_in">int</span> minSize = mins.<span class="built_in">size</span>();
            <span class="built_in">int</span> minTop = mins.<span class="built_in">get</span>(minSize-<span class="number">1</span>);
            <span class="keyword">if</span>(top == minTop) {
                mins.remove(minSize-<span class="number">1</span>);
            }
            nums.remove(<span class="built_in">size</span>-<span class="number">1</span>);
        }        
    }

    <span class="keyword">public</span> <span class="built_in">int</span> top() {
        <span class="built_in">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();
        <span class="keyword">if</span>  (<span class="built_in">size</span>&gt;<span class="number">0</span>) {
            <span class="keyword">return</span> nums.<span class="built_in">get</span>(<span class="built_in">size</span>-<span class="number">1</span>);
        } <span class="keyword">else</span> {
            System.out.<span class="built_in">println</span>(<span class="string">"size is 0"</span>);
        }
        <span class="keyword">return</span> (Integer) <span class="keyword">null</span>;
    }

    <span class="keyword">public</span> <span class="built_in">int</span> getMin() {

        <span class="built_in">int</span> minSize = mins.<span class="built_in">size</span>();
        <span class="keyword">if</span>(minSize&gt;<span class="number">0</span>) {
            <span class="keyword">return</span> mins.<span class="built_in">get</span>(minSize-<span class="number">1</span>);
        }
        <span class="keyword">return</span> (Integer) <span class="keyword">null</span>;
    }
}
</code></pre><p>运行时间为432ms，显著减少。</p>
<p>以上两种方法均用数组列表来解决这个问题，也有人用Java内置的Stack类实现，方法是一样的，只是Stack类本身有push()、pop()、peek()等方法，代码会简洁一些，如下所示：</p>
<pre><code><span class="keyword">class</span> MinStack {

    Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
        <span class="built_in">stack</span>.push(x);
        <span class="keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) {
            minStack.push(x);
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{
        <span class="keyword">if</span> (!<span class="built_in">stack</span>.isEmpty()) {
            <span class="keyword">int</span> top = <span class="built_in">stack</span>.peek();
            <span class="keyword">if</span> (top == minStack.peek()) {
                minStack.pop();
            }
            <span class="built_in">stack</span>.pop();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{

        <span class="keyword">return</span> <span class="built_in">stack</span>.peek();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{

        <span class="keyword">return</span> minStack.peek();
    }
}
</code></pre><p>运行时间为468ms，与用数组列表差别不大。</p>
<h3 id="Tips:">Tips:</h3><ul>
<li>数组和数组列表的选取：如果经常需要在运行过程中扩展数组的大小，就应该使用数组列表。数组的长度一旦确定，就无法更改。</li>
<li>当需要返回int类型的值而有可能无法返回时，可以返回null,但是需要做强制类型转换。</li>
</ul>
<h3 id="References:">References:</h3><ul>
<li><a href="http://blog.csdn.net/ljiabin/article/details/40982153" target="_blank" rel="external">http://blog.csdn.net/ljiabin/article/details/40982153</a></li>
<li><a href="http://blog.csdn.net/linhuanmars/article/details/41008731" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/41008731</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-27T08:47:59.000Z"><a href="/2015/04/27/Count-Primes/">2015-04-27</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/27/Count-Primes/">Count Primes</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Problem:">Problem:</h3><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p><strong>*Hint:</strong> The number n could be in the order of 100,000 to 5,000,000.*</p>
<p><a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="external">from LeetCode</a></p>
<h3 id="References:">References:</h3><h3 id="Solution:">Solution:</h3><p>首先想到这种最简单的解法：</p>
<pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> k</span>) </span>{
    <span class="keyword">int</span> n = nums.length;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) {
        <span class="keyword">int</span> temp = nums[n-<span class="number">1</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--) {
            nums[j] = nums[j-<span class="number">1</span>];
        }
        nums[<span class="number">0</span>] = temp;
    }
}
</code></pre><p>时间复杂度非常高，每次循环要把整个数组的所有元素都向后移一位，总共要进行 <code>k*n</code> 次操作。</p>
<p>上网查询后发现这样一种巧妙的方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> void rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) {
        <span class="built_in">int</span> n = nums.length;
        <span class="keyword">if</span>(k&gt;n) {
            k = k%n;
        }
        <span class="keyword">if</span>(k!=<span class="number">0</span>){
            reverseArray(nums, <span class="number">0</span>, n-<span class="number">1</span>);
            reverseArray(nums, <span class="number">0</span>, k-<span class="number">1</span>);
            reverseArray(nums, k, n-<span class="number">1</span>);
        }

    }

    <span class="keyword">public</span> void reverseArray (<span class="built_in">int</span>[] <span class="built_in">array</span>, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) {
        <span class="keyword">while</span>(<span class="built_in">left</span>&lt;<span class="built_in">right</span>) {
            <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
            <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
            <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            <span class="built_in">left</span>++;
            <span class="built_in">right</span>--;
        }
    }
}
</code></pre><p>将整个数组分成两段，下标从 0 到 k-1 为第一段，从 k 到 n-1 为第二段。首先对整个数组进行对折翻转，再分别对第一段和第二段进行对折翻转。总共要进行 <code>2n</code> 次操作，时间复杂度大大降低。</p>
<p><a href="http://articles.leetcode.com/2010/04/rotating-array-in-place.html" target="_blank" rel="external">原文链接</a></p>
<h3 id="Tips:">Tips:</h3><ul>
<li>将数组作为参数传入一个方法后，若在方法中对数组进行操作，会改变数组的状态。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-22T02:33:18.000Z"><a href="/2015/04/22/Rotate-Array/">2015-04-22</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/22/Rotate-Array/">Rotate Array</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Problem:">Problem:</h3><p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="external">from LeetCode</a></p>
<h3 id="Solution:">Solution:</h3><p>首先想到这种最简单的解法：</p>
<pre><code><span class="keyword">class</span> <span class="title">Solution</span> {
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> k</span>) </span>{
    <span class="keyword">int</span> n = nums.length;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) {
        <span class="keyword">int</span> temp = nums[n-<span class="number">1</span>];
        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--) {
            nums[j] = nums[j-<span class="number">1</span>];
        }
        nums[<span class="number">0</span>] = temp;
    }
}
</code></pre><p>时间复杂度非常高，每次循环要把整个数组的所有元素都向后移一位，总共要进行 <code>k*n</code> 次操作。</p>
<p>上网查询后发现这样一种巧妙的方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> Solution {
    <span class="keyword">public</span> void rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) {
        <span class="built_in">int</span> n = nums.length;
        <span class="keyword">if</span>(k&gt;n) {
            k = k%n;
        }
        <span class="keyword">if</span>(k!=<span class="number">0</span>){
            reverseArray(nums, <span class="number">0</span>, n-<span class="number">1</span>);
            reverseArray(nums, <span class="number">0</span>, k-<span class="number">1</span>);
            reverseArray(nums, k, n-<span class="number">1</span>);
        }

    }

    <span class="keyword">public</span> void reverseArray (<span class="built_in">int</span>[] <span class="built_in">array</span>, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) {
        <span class="keyword">while</span>(<span class="built_in">left</span>&lt;<span class="built_in">right</span>) {
            <span class="built_in">int</span> temp = <span class="built_in">array</span>[<span class="built_in">left</span>];
            <span class="built_in">array</span>[<span class="built_in">left</span>] = <span class="built_in">array</span>[<span class="built_in">right</span>];
            <span class="built_in">array</span>[<span class="built_in">right</span>] = temp;
            <span class="built_in">left</span>++;
            <span class="built_in">right</span>--;
        }
    }
}
</code></pre><p>将整个数组分成两段，下标从 0 到 k-1 为第一段，从 k 到 n-1 为第二段。首先对整个数组进行对折翻转，再分别对第一段和第二段进行对折翻转。总共要进行 <code>2n</code> 次操作，时间复杂度大大降低。</p>
<p><a href="http://articles.leetcode.com/2010/04/rotating-array-in-place.html" target="_blank" rel="external">原文链接</a></p>
<h3 id="Tips:">Tips:</h3><ul>
<li>将数组作为参数传入一个方法后，若在方法中对数组进行操作，会改变数组的状态。</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/07/15/Minimum-Depth-of-Binary-Tree/">Minimum-Depth-of-Binary-Tree</a>
      </li>
    
      <li>
        <a href="/2015/07/13/Palindrome-Linked-List/">Palindrome Linked List</a>
      </li>
    
      <li>
        <a href="/2015/07/06/Min-Stack/">Min Stack</a>
      </li>
    
      <li>
        <a href="/2015/04/27/Count-Primes/">Count Primes</a>
      </li>
    
      <li>
        <a href="/2015/04/22/Rotate-Array/">Rotate Array</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Binary-Tree/">Binary Tree</a><small>1</small></li>
  
    <li><a href="/tags/Breadth-first-Search/">Breadth-first Search</a><small>1</small></li>
  
    <li><a href="/tags/Data-Structure/">Data Structure</a><small>1</small></li>
  
    <li><a href="/tags/Depth-first-Search/">Depth-first Search</a><small>1</small></li>
  
    <li><a href="/tags/Linked-List/">Linked List</a><small>1</small></li>
  
    <li><a href="/tags/Palindrome/">Palindrome</a><small>1</small></li>
  
    <li><a href="/tags/Stack/">Stack</a><small>1</small></li>
  
    <li><a href="/tags/algorithm/">algorithm</a><small>2</small></li>
  
    <li><a href="/tags/array/">array</a><small>1</small></li>
  
    <li><a href="/tags/prime/">prime</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Yang Guoyu
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>